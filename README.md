* Structura unui fisier care contine intrebarile este urmatoarea:

 text_intrebare
 
 varianta 1
 
 varianta 2
 
 varianta 3
 
 varianta 4
 
 raspuns_corect(A/B/C/D)
 hint
 
In fisierele de intrare nu am inclus linii goale.
* Pentru a putea memora intrebarile preluate din fisierele date ca argumente la executie, am definit doua tipuri de date denumite question respectiv date; question are 7 campuri definite ca siruri de caractere:text memoreaza textul intrebarii, var1 (2,3,4) memoreaza variantele de raspuns, raspuns memoreaza raspunsul corect iar hint memoreaza numele unei imagini aflata in directorul in care se afla fisierul cu codul sursa sau memoreaza sirul "nothing".Tipul de date denumit date are 2 campuri: intrebari si nr; intrebari este un vector de tipul question descris anterior iar nr este o variabila de tip int care memoreaza numarul de intrebati continute in vectorul de tip question. 
Intrebarile vor fi memorate intr-un vector de tip date, vectorul fiind definit in main: date *A; Memorarea intrebarilor in memoria interna a programului se face in cadrul functiei cu antetul date *preluare_intrebari(int argc, char *argv[]). Prin intermediul variabilei de tip FILE* sunt accesate pe rand fisierele cu intrebari. Vectorul de tip date care memoreaza intrebarile este declarat astfel: date *input si este alocat dinamic, avand o sigura componenta. Primul camp al vectorului de tip date, vectorul de tip question, este, de asemenea, alocat dinamic, cu o capacitate initiala de 3 componente. Am accesat, prin variabila FILE *intrebari, fiecare fisier citind linie cu linie continutul acestuia, linia curenta fiind memorata in sirul de caractere definit char sir[100]. Pentru a plasa linia curenta din fisier in campul corespunzator din vectorul de tip question denumit a, am folosit o variabila i care se incrementeaza la o noua linie citita. Conform structurii fisierului cu intrebari care aloca 7 linii pentru fiecare intrebare, am copiat in campul corespunzator din a[j] sirul sir folosind functia strdup. Variabila j este folosita pentru a determina numarul de intrebari preluate din fisiere, aceasta incrementandu-se atunci cand sunt completate toate campurile din componenta curenta a vectorului de tip question. Daca capacitatea curenta a vectorului cu intrebari a fost atinsa (adica j==cap), atunci se dubleaza capacitatea vectorului si se realoca spatiu pentru noua capacitate. Dupa ce s-au parcurs toate fisierele si s-au copiat intrebarile in vector, am realocat din nou spatiu pentru vectorul de tip question,a, astfel incat capacitatea sa se reduca la un numar de componente egal cu intrebarile continute in vector. Apoi am copiat in campul intrebari din variabila input de tip date vectorul de structuri a iar in campul nr numarul de intrebari din vectorul a. In final, functia preluare_intrebari returneaza variabila de tip date, input.

 * Pentru a afisa meniul aplicati am definit functiile meniu si print_meniu. In cadrul meniului, sunt 4 optiuni, cele specificate in cadrul Cerintei 1 la care am adaugat si optiunea "View score list". Functia meniu returneaza un intreg(1,2,3,4) reprezentand indicele asociat alegerii facute de utilizator. Pentru a afisa optiunile din meniu se folosesc apeluri repetate ale functiei print_menu; functia se apeleaza de fiecare data cand se apasa una din tastele KEY_UP si KEY_DOWN, primind ca parametru alegerea curenta a utilizatorului (in variabila alegere), marcand optiunea aferenta la afisare prin highlight pe scris. Atunci cand se apasa tasta ENTER (cu codul ASCII 10), se actualizeaza variabila choice cu indicele optiunii curente, iesind deci din bucla infinita atunci cand utilizatorul a ales una din optiuni (aceasta se verifica prin valorea lui choice,initializat cu 0).
Prima optiune din meniu, New Game, determina afisarea unei noi ferestre in care i se cere jucatorului numele (acesta va fi folosit la afisarea unui score list); introducerea numele este urmata de apasarea tastei ENTER pentru a putea incepe jocul.
*Optiunea implementata ca bonus este cea care permite afisarea unei liste cu scoruri. Aceasta contine numele jucatorului, punctajul obtinut,data si ora la care s-a incheiat jocul. Optiunea View score list nu este disponibila in timpul jocului (adica atunci cand se revine la meniu in timpul jocului apasand tasta Q). Daca jucatorul alege aceasta optiune in timpul jocului, se va afisa un mesaj catre acesta iar revenirea la joc se face apasand tasta b sau B (apasarea oricarei alte taste va inchide aplicatia). Pentru a memora aceste date referitoare la jocurile anterioare am definit un tip de date istoric care contine campurile nume (un sir de caractere), punctaj si tm, structura in care se memoreaza data si ora curenta la care s-a inregistrat un anume punctaj. Am definit functia autentificare apelata la fiecare inceput de joc, aceasta returnand sirul de caractere introdus de jucator ca si nume si plasat apoi in campul nume al unei variabile de tip istoric (denumita user) si definita la fiecare joc nou inceput. La finalul jocului (dupa ce sunt parcurse toate intrebarile din fisiere), se memoreaza in campul punctaj scorul obtinut de jucator si in campul tm ora si data curenta. Apoi aceste date sunt scrise in fisierul score_list.txt, la selectarea optiunii 'view score list' afisandu-se continutul acestui fisier si apoi un mesaj catre jucator, permitand revenirea la meniu prin apasarea tastei m sau M (orice alta tasta va inchide aplicatia).
* La inceputul unui nou joc, dupa afisarea "ferestrei de autentificare" si apasarea tastei ENTER sunt afisate pe rand intrebarile, trecerea la urmatoarea intrebare fiind conditionata de alegerea raspunsului corect. Afisarea variantelor de raspuns se face folosind aceeasi functie prin care se afisau optiunile din meniu; trecerea de la o varianta de raspuns la alta se face folosind sageti sus-jos iar selectarea unui anumit raspuns se face prin apasarea tastei ENTER. 
Optiunea "Skip this question" se aplica la apasarea tastei N, determinand un salt peste componenta curenta din vectorul cu intrebari. Pentru optiunea 50/50 se apasa tasta H; pentru a "elimina" 2 din raspunsurile gresite, am inlocuit textul aferent variantelor respective cu un sir format din caracterul space iar la afisarea variantelor de raspuns (folosind functia print_meniu) s-a afisat secventa ---------- pentru variantele eliminate (identificate prin compararea cu " "). Daca se alege pentru a doua oara una din variantele ajutatoare, se va da un mesaj catre jucator(in momentul apasarii uneia din tastele H sau N), deoarece cele doua optiuni se pot folosi o sigura data in cadrul unui joc.
La finalul jocului, dupa parcurgerea tuturor intrebarilor, este afisat punctajul obtinut, nr de raspunsuri corecte si gresite. Jucatorul poate reveni in meniu apasand tasta m iar apasarea oricarei alte taste va inchide aplicatia (in meniul afisat in acest context este indisposibila optiunea Resume Game; alegerea ei va determina inchiderea aplicatiei).
* Afisarea intrebarilor in cadrul unui joc se face in mod aleator, la fiecare nou joc ordinea intrebarilor este diferita. Pentru aceasta am definit un vector care sa memoreze indicii cu care se acceseaza componentele vectorului de structuri (cel care memoreaza intrebarile preluate din fisier in cadrul functiei preluare_intrebari). Acest vector de indici este generat in functia void generare_vector, fiecare componenta a sa fiind un numar din intervalul 0,a->nr-1, unde a->nr memoreaza numarul de intrebari din fisiere.
*La o parte din intrebarile textului este disponibila optiunea de a obtine un hint grafic. Acesta consta in afisarea unei imagini care poate reprezenta un indiciu in gasirea raspunsului. Ultima informatie memorata in fisier pentru fiecare intrebare, hintul, este fie sirul "nothing" 
(cand nu am posibilitatea unui hint), fie numele unui fisier imagine de forma i.png unde i este indicele care arata pozitia intrebarii in fisiere (in ordinea parcurgerii fisierelor de la intrebari1.txt la intrebari3.txt). Pentru a verifica daca intrebarea curenta care se afiseaza in cadrul ferestrei joc dispune de hint am comparat sirul memorat in campul hint (preluat anterior din fisierele cu intrebari) cu sirul "nothing" (in caz afirmativ se afiseaza un mesaj in cadrul ferestrei si se poate apasa tasta w/W pentru afisarea imaginii corespunzatoare). Afisarea unui imagini se realizeaza folosind utilitarul feh si functia system. Utilitarul feh are optiunea -x pentru a afisa imaginea fara bord si -g pentru a seta dimensiunile imaginii (inchiderea imaginii se face prin apasarea tastei x).
Fisierele de intrare atasate contin 26 de intrebari iar 8 dintre acestea dispun de un hint.
*In implementarea jocului, am folosit 2 ferestre: menu_win (pentru a afisa continutul meniului principal cu 4 optiuni) si joc (pentru intrebari si variante de raspuns) dar si standard screen pentru vizualizare listei de scoruri. Pentru fereastra joc am setat dimensiunea 79x23, pentru a incadra aceasta fereastra in terminalul cu dimensiunea standard 80x24; fereastra meniu are dimeniunile 60X150.
Textul intrebarii si variantele de raspuns au culoarea albastru iar data si ora culoare cyan (pe un fundal negru).


